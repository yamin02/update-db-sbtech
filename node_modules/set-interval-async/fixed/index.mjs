import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';

/**
 * Copyright (c) 2019 Emilio Almansi. All rights reserved.
 * This work is licensed under the terms of the MIT license.
 * For a copy, see the file LICENSE in the root directory.
 */

/**
 * Error thrown by setIntervalAsync when invalid arguments are provided.
 */
class SetIntervalAsyncError extends Error {}

Object.defineProperty(SetIntervalAsyncError.prototype, 'name', {
  value: 'SetIntervalAsyncError'
});

/**
 * Copyright (c) 2019-2021 Emilio Almansi. All rights reserved.
 * This work is licensed under the terms of the MIT license.
 * For a copy, see the file LICENSE in the root directory.
 */
const MIN_INTERVAL_MS = 10;
/**
 * @private
 *
 * @param {function} handler - Handler function to be executed in intervals.<br>
 *                             May be asynchronous.
 */

function validateHandler(handler) {
  if (!(typeof handler === 'function')) {
    throw new SetIntervalAsyncError('Invalid argument: "handler". Expected a function.');
  }
}
/**
 * @private
 *
 * @param {number} interval - Interval in milliseconds. Must be at least 10 ms.
 */

function validateInterval(interval) {
  if (!(typeof interval === 'number' && MIN_INTERVAL_MS <= interval)) {
    throw new SetIntervalAsyncError(`Invalid argument: "interval". Expected a number greater than or equal to ${MIN_INTERVAL_MS}.`);
  }
}
/**
 * @private
 *
 * @param {SetIntervalAsyncTimer} timer
 */

function validateTimer(timer) {
  if (!(timer && 'stopped' in timer && 'timeouts' in timer && 'promises' in timer)) {
    throw new SetIntervalAsyncError('Invalid argument: "timer". Expected an instance of SetIntervalAsyncTimer.');
  }
}

/**
 * Stops an execution cycle started by setIntervalAsync.<br>
 * Any ongoing function executions will run until completion,
 * but all future ones will be cancelled.
 *
 * @param {SetIntervalAsyncTimer} timer
 * @returns {Promise}
 *          A promise which resolves when all pending executions have finished.
 */

function clearIntervalAsync(_x) {
  return _clearIntervalAsync.apply(this, arguments);
}

function _clearIntervalAsync() {
  _clearIntervalAsync = _asyncToGenerator(function* (timer) {
    validateTimer(timer);
    timer.stopped = true;

    for (const iterationId in timer.timeouts) {
      clearTimeout(timer.timeouts[iterationId]);
      delete timer.timeouts[iterationId];
    }

    for (const iterationId in timer.promises) {
      try {
        yield timer.promises[iterationId];
      } catch (_) {// Do nothing.
      }

      delete timer.promises[iterationId];
    }
  });
  return _clearIntervalAsync.apply(this, arguments);
}

/**
 * Copyright (c) 2019 Emilio Almansi. All rights reserved.
 * This work is licensed under the terms of the MIT license.
 * For a copy, see the file LICENSE in the root directory.
 */

/**
 * Timer object returned by setIntervalAsync.<br>
 * Can be used together with {@link clearIntervalAsync} to stop execution.
 */
class SetIntervalAsyncTimer {
  constructor() {
    this.stopped = false;
    this.timeouts = {};
    this.promises = {};
  }

}

/**
 * Copyright (c) 2021 Emilio Almansi. All rights reserved.
 * This work is licensed under the terms of the MIT license.
 * For a copy, see the file LICENSE in the root directory.
 */

/**
 * @private
 *
 * @param {SetIntervalAsyncTimer} timer
 */
function getNextIterationId(iterationId) {
  if (iterationId === Number.MAX_SAFE_INTEGER) {
    return 0;
  }

  return iterationId + 1;
}
/**
 * @private
 */

function noop() {
  return _noop.apply(this, arguments);
}

function _noop() {
  _noop = _asyncToGenerator(function* () {});
  return _noop.apply(this, arguments);
}

/**
 * Executes the given handler at fixed intervals, while preventing<br>
 * multiple concurrent executions. The handler will never be executed<br>
 * concurrently more than once in any given moment, providing a fixed<br>
 * time interval between the <strong>end</strong> of a given execution and the <strong>start</strong> of<br>
 * the following one.
 *
 * @param {function} handler - Handler function to be executed in intervals.<br>
 *                             May be asynchronous.
 * @param {number} interval - Interval in milliseconds. Must be at least 10 ms.
 * @param {...*} args - Any number of arguments to pass on to the handler.
 * @returns {SetIntervalAsyncTimer}
 *          A timer object which can be used to stop execution with {@link clearIntervalAsync}.
 *
 * @alias [Fixed] setIntervalAsync
 */

function setIntervalAsync(handler, interval, ...args) {
  validateHandler(handler);
  validateInterval(interval);
  const timer = new SetIntervalAsyncTimer();
  const iterationId = 0;
  timer.timeouts[iterationId] = setTimeout(timeoutHandler, interval, timer, iterationId, handler, interval, ...args);
  return timer;
}
/**
 * @private
 *
 * @param {SetIntervalAsyncTimer} timer
 * @param {number} iterationId
 * @param {function} handler
 * @param {number} interval
 * @param {...*} args
 */


function timeoutHandler(timer, iterationId, handler, interval, ...args) {
  delete timer.timeouts[iterationId];
  timer.promises[iterationId] = runHandler(timer, iterationId, handler, interval, ...args);
}
/**
 * @private
 *
 * @param {SetIntervalAsyncTimer} timer
 * @param {number} iterationId
 * @param {function} handler
 * @param {number} interval
 * @param {...*} args
 */


function runHandler(_x, _x2, _x3, _x4) {
  return _runHandler.apply(this, arguments);
}

function _runHandler() {
  _runHandler = _asyncToGenerator(function* (timer, iterationId, handler, interval, ...args) {
    // The next line ensures that timer.promises[iterationId] is set
    // before running the handler.
    yield noop();

    try {
      yield handler(...args);
    } finally {
      if (!timer.stopped) {
        const nextIterationId = getNextIterationId(iterationId);
        timer.timeouts[nextIterationId] = setTimeout(timeoutHandler, interval, timer, nextIterationId, handler, interval, ...args);
      }

      delete timer.promises[iterationId];
    }
  });
  return _runHandler.apply(this, arguments);
}

export { SetIntervalAsyncError, SetIntervalAsyncTimer, clearIntervalAsync, setIntervalAsync };
//# sourceMappingURL=index.mjs.map
