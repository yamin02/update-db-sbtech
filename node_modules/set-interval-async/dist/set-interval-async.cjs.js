'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _asyncToGenerator = _interopDefault(require('@babel/runtime/helpers/asyncToGenerator'));

/**
 * Copyright (c) 2019 Emilio Almansi. All rights reserved.
 * This work is licensed under the terms of the MIT license.
 * For a copy, see the file LICENSE in the root directory.
 */

/**
 * Error thrown by setIntervalAsync when invalid arguments are provided.
 */
class SetIntervalAsyncError extends Error {}

Object.defineProperty(SetIntervalAsyncError.prototype, 'name', {
  value: 'SetIntervalAsyncError'
});

/**
 * Copyright (c) 2019-2021 Emilio Almansi. All rights reserved.
 * This work is licensed under the terms of the MIT license.
 * For a copy, see the file LICENSE in the root directory.
 */
const MIN_INTERVAL_MS = 10;
/**
 * @private
 *
 * @param {function} handler - Handler function to be executed in intervals.<br>
 *                             May be asynchronous.
 */

function validateHandler(handler) {
  if (!(typeof handler === 'function')) {
    throw new SetIntervalAsyncError('Invalid argument: "handler". Expected a function.');
  }
}
/**
 * @private
 *
 * @param {number} interval - Interval in milliseconds. Must be at least 10 ms.
 */

function validateInterval(interval) {
  if (!(typeof interval === 'number' && MIN_INTERVAL_MS <= interval)) {
    throw new SetIntervalAsyncError(`Invalid argument: "interval". Expected a number greater than or equal to ${MIN_INTERVAL_MS}.`);
  }
}
/**
 * @private
 *
 * @param {SetIntervalAsyncTimer} timer
 */

function validateTimer(timer) {
  if (!(timer && 'stopped' in timer && 'timeouts' in timer && 'promises' in timer)) {
    throw new SetIntervalAsyncError('Invalid argument: "timer". Expected an instance of SetIntervalAsyncTimer.');
  }
}

/**
 * Stops an execution cycle started by setIntervalAsync.<br>
 * Any ongoing function executions will run until completion,
 * but all future ones will be cancelled.
 *
 * @param {SetIntervalAsyncTimer} timer
 * @returns {Promise}
 *          A promise which resolves when all pending executions have finished.
 */

function clearIntervalAsync(_x) {
  return _clearIntervalAsync.apply(this, arguments);
}

function _clearIntervalAsync() {
  _clearIntervalAsync = _asyncToGenerator(function* (timer) {
    validateTimer(timer);
    timer.stopped = true;

    for (const iterationId in timer.timeouts) {
      clearTimeout(timer.timeouts[iterationId]);
      delete timer.timeouts[iterationId];
    }

    for (const iterationId in timer.promises) {
      try {
        yield timer.promises[iterationId];
      } catch (_) {// Do nothing.
      }

      delete timer.promises[iterationId];
    }
  });
  return _clearIntervalAsync.apply(this, arguments);
}

/**
 * Copyright (c) 2019 Emilio Almansi. All rights reserved.
 * This work is licensed under the terms of the MIT license.
 * For a copy, see the file LICENSE in the root directory.
 */

/**
 * Timer object returned by setIntervalAsync.<br>
 * Can be used together with {@link clearIntervalAsync} to stop execution.
 */
class SetIntervalAsyncTimer {
  constructor() {
    this.stopped = false;
    this.timeouts = {};
    this.promises = {};
  }

}

/**
 * Copyright (c) 2021 Emilio Almansi. All rights reserved.
 * This work is licensed under the terms of the MIT license.
 * For a copy, see the file LICENSE in the root directory.
 */

/**
 * @private
 *
 * @param {SetIntervalAsyncTimer} timer
 */
function getNextIterationId(iterationId) {
  if (iterationId === Number.MAX_SAFE_INTEGER) {
    return 0;
  }

  return iterationId + 1;
}
/**
 * @private
 */

function noop() {
  return _noop.apply(this, arguments);
}

function _noop() {
  _noop = _asyncToGenerator(function* () {});
  return _noop.apply(this, arguments);
}

/**
 * Attempts to execute the given handler at regular intervals, while preventing<br>
 * multiple concurrent executions. The handler will never be executed concurrently<br>
 * more than once in any given moment. If the running time of any execution exceeds<br>
 * the desired interval, the following execution will be scheduled as soon as<br>
 * possible; ie. immediately after the previous execution concludes.
 *
 * @param {function} handler - Handler function to be executed in intervals.<br>
 *                             May be asynchronous.
 * @param {number} interval - Interval in milliseconds. Must be at least 10 ms.
 * @param {...*} args - Any number of arguments to pass on to the handler.
 * @returns {SetIntervalAsyncTimer}
 *          A timer object which can be used to stop execution with {@link clearIntervalAsync}.
 *
 * @alias [Dynamic] setIntervalAsync
 */

function setIntervalAsync(handler, interval, ...args) {
  validateHandler(handler);
  validateInterval(interval);
  const timer = new SetIntervalAsyncTimer();
  const iterationId = 0;
  timer.timeouts[iterationId] = setTimeout(timeoutHandler, interval, timer, iterationId, handler, interval, ...args);
  return timer;
}
/**
 * @private
 *
 * @param {SetIntervalAsyncTimer} timer
 * @param {number} iterationId
 * @param {function} handler
 * @param {number} interval
 * @param {...*} args
 */


function timeoutHandler(timer, iterationId, handler, interval, ...args) {
  delete timer.timeouts[iterationId];
  timer.promises[iterationId] = runHandler(timer, iterationId, handler, interval, ...args);
}
/**
 * @private
 *
 * @param {SetIntervalAsyncTimer} timer
 * @param {number} iterationId
 * @param {function} handler
 * @param {number} interval
 * @param {...*} args
 */


function runHandler(_x, _x2, _x3, _x4) {
  return _runHandler.apply(this, arguments);
}

function _runHandler() {
  _runHandler = _asyncToGenerator(function* (timer, iterationId, handler, interval, ...args) {
    // The next line ensures that timer.promises[iterationId] is set
    // before running the handler.
    yield noop();
    const startTime = new Date();

    try {
      yield handler(...args);
    } finally {
      if (!timer.stopped) {
        const endTime = new Date();
        const executionTime = endTime - startTime;
        const timeout = interval > executionTime ? interval - executionTime : 0;
        const nextIterationId = getNextIterationId(iterationId);
        timer.timeouts[nextIterationId] = setTimeout(timeoutHandler, timeout, timer, nextIterationId, handler, interval, ...args);
      }

      delete timer.promises[iterationId];
    }
  });
  return _runHandler.apply(this, arguments);
}

/**
 * Executes the given handler at fixed intervals, while preventing<br>
 * multiple concurrent executions. The handler will never be executed<br>
 * concurrently more than once in any given moment, providing a fixed<br>
 * time interval between the <strong>end</strong> of a given execution and the <strong>start</strong> of<br>
 * the following one.
 *
 * @param {function} handler - Handler function to be executed in intervals.<br>
 *                             May be asynchronous.
 * @param {number} interval - Interval in milliseconds. Must be at least 10 ms.
 * @param {...*} args - Any number of arguments to pass on to the handler.
 * @returns {SetIntervalAsyncTimer}
 *          A timer object which can be used to stop execution with {@link clearIntervalAsync}.
 *
 * @alias [Fixed] setIntervalAsync
 */

function setIntervalAsync$1(handler, interval, ...args) {
  validateHandler(handler);
  validateInterval(interval);
  const timer = new SetIntervalAsyncTimer();
  const iterationId = 0;
  timer.timeouts[iterationId] = setTimeout(timeoutHandler$1, interval, timer, iterationId, handler, interval, ...args);
  return timer;
}
/**
 * @private
 *
 * @param {SetIntervalAsyncTimer} timer
 * @param {number} iterationId
 * @param {function} handler
 * @param {number} interval
 * @param {...*} args
 */


function timeoutHandler$1(timer, iterationId, handler, interval, ...args) {
  delete timer.timeouts[iterationId];
  timer.promises[iterationId] = runHandler$1(timer, iterationId, handler, interval, ...args);
}
/**
 * @private
 *
 * @param {SetIntervalAsyncTimer} timer
 * @param {number} iterationId
 * @param {function} handler
 * @param {number} interval
 * @param {...*} args
 */


function runHandler$1(_x, _x2, _x3, _x4) {
  return _runHandler$1.apply(this, arguments);
}

function _runHandler$1() {
  _runHandler$1 = _asyncToGenerator(function* (timer, iterationId, handler, interval, ...args) {
    // The next line ensures that timer.promises[iterationId] is set
    // before running the handler.
    yield noop();

    try {
      yield handler(...args);
    } finally {
      if (!timer.stopped) {
        const nextIterationId = getNextIterationId(iterationId);
        timer.timeouts[nextIterationId] = setTimeout(timeoutHandler$1, interval, timer, nextIterationId, handler, interval, ...args);
      }

      delete timer.promises[iterationId];
    }
  });
  return _runHandler$1.apply(this, arguments);
}

/**
 * Executes the given handler at fixed intervals; ie. the start time<br>
 * between consecutive executions is always a fixed amount of time.<br>
 * If a given execution takes longer than the given time interval to<br>
 * complete, then the handler will be invoked again without waiting<br>
 * for the previous one to finish. In this scenario, multiple concurrent<br>
 * executions can and will ocurr, so this function should only be used<br>
 * when the given handler is reentrancy-safe.
 *
 * @param {function} handler - Handler function to be executed in intervals.<br>
 *                             May be asynchronous.
 * @param {number} interval - Interval in milliseconds. Must be at least 10 ms.
 * @param {...*} args - Any number of arguments to pass on to the handler.
 * @returns {SetIntervalAsyncTimer}
 *          A timer object which can be used to stop execution with {@link clearIntervalAsync}.
 *
 * @alias [Legacy] setIntervalAsync
 */

function setIntervalAsync$2(handler, interval, ...args) {
  validateHandler(handler);
  validateInterval(interval);
  const timer = new SetIntervalAsyncTimer();
  const iterationId = 0;
  timer.timeouts[iterationId] = setTimeout(timeoutHandler$2, interval, timer, iterationId, handler, interval, ...args);
  return timer;
}
/**
 * @private
 *
 * @param {SetIntervalAsyncTimer} timer
 * @param {number} iterationId
 * @param {function} handler
 * @param {number} interval
 * @param {...*} args
 */


function timeoutHandler$2(timer, iterationId, handler, interval, ...args) {
  delete timer.timeouts[iterationId];
  timer.promises[iterationId] = runHandler$2(timer, iterationId, handler, interval, ...args);
}
/**
 * @private
 *
 * @param {SetIntervalAsyncTimer} timer
 * @param {number} iterationId
 * @param {function} handler
 * @param {number} interval
 * @param {...*} args
 */


function runHandler$2(_x, _x2, _x3, _x4) {
  return _runHandler$2.apply(this, arguments);
}

function _runHandler$2() {
  _runHandler$2 = _asyncToGenerator(function* (timer, iterationId, handler, interval, ...args) {
    // The next line ensures that timer.promises[iterationId] is set
    // before running the handler.
    yield noop();
    const nextIterationId = getNextIterationId(iterationId);
    timer.timeouts[nextIterationId] = setTimeout(timeoutHandler$2, interval, timer, nextIterationId, handler, interval, ...args);

    try {
      yield handler(...args);
    } finally {
      delete timer.promises[iterationId];
    }
  });
  return _runHandler$2.apply(this, arguments);
}

/**
 * Copyright (c) 2019 Emilio Almansi. All rights reserved.
 * This work is licensed under the terms of the MIT license.
 * For a copy, see the file LICENSE in the root directory.
 */
const dynamic = {
  setIntervalAsync: setIntervalAsync
};
const fixed = {
  setIntervalAsync: setIntervalAsync$1
};
const legacy = {
  setIntervalAsync: setIntervalAsync$2
};

exports.SetIntervalAsyncError = SetIntervalAsyncError;
exports.SetIntervalAsyncTimer = SetIntervalAsyncTimer;
exports.clearIntervalAsync = clearIntervalAsync;
exports.dynamic = dynamic;
exports.fixed = fixed;
exports.legacy = legacy;
//# sourceMappingURL=set-interval-async.cjs.js.map
